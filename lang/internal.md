# композиция

Композиция - передача `a . b` - передача результата a в функцию b.

```haskell
a :: String -> String
b :: String -> String
c :: String -> String


compose = a . b . c
```

```haskell
a :: String -> Either Error String
b :: String -> String
c :: String -> Either Error String

Right a >>= f = f a
Left b >>= f = b

compose = a . >>= . b . c
compose = a >>= b c
```

Применение - применение параметров к функции. >>= применяет параметр к функции, но это не композиция.

Виды соединения:
- компоизия, когда вывод направляется на ввод
- применение. Пример применения: вывод `a`, который типа `Right String` направляется в `>>= b`, то есть: `a . >>= b`. Функция `>>=` ожидает на вход `Right String`. Функция `b` ожидает `String`, а результат у неё тоже `Right String`. То есть монада получает результат `a` с помощью композиции; убирает конструктор типа, оставляя только `String` и передаёт это занчение функции `b`. Функция `b` выполняется, а её результат с помощью композиции идёт дальше. То есть монаду можно было бы изобразить так: `a . >>= (b) . c`, где `c :: Right String -> String`.

Теперь про тоже самое в haskell: `a >>= b c`. По сути только пропущены скобочки.

Итак, если `>>=` применяет свой аргумент к результату пришедшему из композиции, тогда `>>= b` является своего рода сервисом с предобработкой данных. `>>=` является сервисом, незаметно встраивающимся в последовательность вызова. Так как таких функций всего несколько, они реализованы  платформой Anzer и являются просто прокси, подставляемыми в нужных местах.