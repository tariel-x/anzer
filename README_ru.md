# Anzer

Прототип транслятора языка оркестрации λ-сервисов.

Цель: создание языка и инструмента для описания взаимодействующих микросервисов в виде одной системы.

Для простоты принято, что сервис максимально приближен по свойствам к чистым функциям, то есть по возможности
имеет один вход-выход и не имеет побочных эффектов. Это упрощение позволяет выразить коммуникацию микросервисов
через их композицию с поддержкой строгой явной статической типизации.

Данный проект - транслятор из языка описания системы λ-сервисов во внутренее представление, отражающее
конкретные сервисы их коммуникацию.

## Anzer lang

### Типы

Система типов языка отражает те данные, которые принимают на вход или отдают отдельные сервисы, их композиция или произведение. Формат описания типов - расширенная json-schema, описание любых передаваемых данных производится через ней. Json-schema, в свою очередь,позволяет описать как скалярные, так и составные типы данных, поэтому никакого другого способа описания типов не предусматривается.

Исключение - описание произведения типов. Произведение 2-х типов в данном случае является кортежем из 2-х элементов и предполагает, что сервису, принимающему это произведение передаётся кортеж данных удовлетворяющих обоим типам из произведения.

Новый тип вводится ключевым словом `data` и названием в верхнем регистре, например:

```
data SOURCE = {
  "type": "string"
}
```

В приведённом примере мы определили, что `SOURCE` - это просто строка символов.

Допустимые символы названия: латинские символы в верхнем регистре и символ подчёркивание `_`.

Более сложный пример:

```
data PERSON = {
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    }
  },
  "required": [
    "firstName"
  ]
}
```

Как можно увидеть из вышеопределённого примера, json-schema позволяет гибко описать данные, передаваемые сервису.

Определение типа как произведение типов:

```
data FOO=SOURCE&PERSON
```

Такой тип будет эквивалентен описанию:

```
data FOO = {
  "title": "Person",
  "type": "object",
  "properties": {
    "PERSON": {
      "title": "Person",
      "type": "object",
      "properties": {
        "firstName": {
          "type": "string"
        }
      },
      "required": [
        "firstName"
      ]
    },
    "SOURCE": {
      "type": "string"
    }
  },
  "required": [
    "PERSON",
    "SOURCE"
  ]
}
```

В примере видно, что сервису, ждущему произведение `SOURCE` и `PERSON` необходимо сообщение содержащее все данные.

### Anzer и теория категорий

Язык вдохновлён Haskell и так же представляет собой простейшую категорию (см. [теория категорий](https://ru.wikipedia.org/wiki/Теория_категорий)). 
