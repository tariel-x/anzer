# Anzer

Прототип транслятора языка оркестрации λ-сервисов.

λ-сервис в данном контекте - это микросервис, работающий асинхронно, имеющий одну ответственность, один вход, один выход и не имееющий побочных эффектов.
В идеале, это ещё и stateless-сервис.

Цель: создание языка и инструмента для описания взаимодействующих микросервисов в виде одной системы.

Данный проект - транслятор из языка описания системы λ-сервисов во внутренее представление, отражающее
конкретные сервисы их коммуникацию.

## Anzer lang

### Типы

Система типов языка отражает те данные, которые принимают на вход или отдают отдельные сервисы, их композиция или произведение. Формат описания типов - расширенная json-schema, описание любых передаваемых данных производится через ней. Json-schema, в свою очередь,позволяет описать как скалярные, так и составные типы данных, поэтому никакого другого способа описания типов не предусматривается.

Исключение - описание произведения типов. Произведение 2-х типов в данном случае является кортежем из 2-х элементов и предполагает, что сервису, принимающему это произведение передаётся кортеж данных удовлетворяющих обоим типам из произведения.

Новый тип вводится ключевым словом `data` и названием в верхнем регистре, например:

```
data SOURCE = {
  "type": "string"
}
```

В приведённом примере мы определили, что `SOURCE` - это просто строка символов.

Допустимые символы названия: латинские символы в верхнем регистре и символ подчёркивание `_`.

Более сложный пример:

```
data PERSON = {
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    }
  },
  "required": [
    "firstName"
  ]
}
```

Как можно увидеть из вышеопределённого примера, json-schema позволяет гибко описать данные, передаваемые сервису.

Определение типа как произведение типов:

```
data FOO=SOURCE&PERSON
```

Такой тип будет эквивалентен описанию:

```
data FOO = {
  "title": "Person",
  "type": "object",
  "properties": {
    "PERSON": {
      "title": "Person",
      "type": "object",
      "properties": {
        "firstName": {
          "type": "string"
        }
      },
      "required": [
        "firstName"
      ]
    },
    "SOURCE": {
      "type": "string"
    }
  },
  "required": [
    "PERSON",
    "SOURCE"
  ]
}
```

В примере видно, что сервису, ждущему произведение `SOURCE` и `PERSON` необходимо сообщение содержащее все данные.

#### Полиморфизм

В оригинале json-schema не подразумевает никакого наследования или каких-либо форм полиморфизма. Однако, транслятор позволяет сравнить 2 схемы и ответить на вопрос:
сможет ли сервис, принимающий тип `A` принять тип `B`. Для этого в json-schema добавлен полиморфизм подтипов.

Допустим есть сервис `a`, принимающий на вход тип :

```
data A = {
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    }
  },
  "required": [
    "firstName"
  ]
}
```

И есть сервис `b`, результат работы которого имеет тип:

```
data B = {
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    },
    "secondName": {
      "type": "string"
    }
  },
  "required": [
    "firstName",
    "secondName"
  ]
}
```

Здесь `A` требует наличие в документе поля `firstName`, поэтому подойдёт любой объект, который содержит это поле. Тип `B` так же требудет наличие этого поля, 
поэтому можно считать, что сервис `b` вернёт документ в с этим полем. Следовательно, возможна композиция сервисов `a . b`, где `a` принимает на вход результат работы `b`.
Следовательно тип `B` можно считать подтипом `A`.

Если же сервис `B` не содержал в секции `required` ключ `firstName`, то этот тип не требовал бы налиичие в документе этого поля и тогда тип `B` нельзя было бы считать подтипом `A`.

Похожие правила распространяются и на свойства полей: e.g. длину строки, регулярное выражние, etc.

### Функции

Язык описывает не композицию сервисов, а композицию функций. Функция в свою очередь может быть λ-сервисом, композицией других функций или произведением функций.

Функция как сервис имеет только сигнатуру и не имеет тела:

```
init :: _ -> SOURCE {
    "env": {
        "abc": "111"
    }
}
```

Сигнатура функции определяет какой тип данных принимает сервис на вход, какой является результатом его работы. `_` - пустой тип, аналог отсутствия параметров в императивных языках.

### Anzer и теория категорий

Язык вдохновлён Haskell и так же представляет собой простейшую категорию (см. [теория категорий](https://ru.wikipedia.org/wiki/Теория_категорий)). 
