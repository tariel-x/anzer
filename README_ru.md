# Anzer

Прототип транслятора языка оркестрации λ-сервисов.

λ-сервис в данном контекте - это микросервис, работающий асинхронно, имеющий одну ответственность, один вход, один выход и не имееющий побочных эффектов.
В идеале, это ещё и stateless-сервис.

Цель: создание языка и инструмента для описания взаимодействующих микросервисов в виде одной системы.

Данный проект - транслятор из языка описания системы λ-сервисов во внутренее представление, отражающее
конкретные сервисы их коммуникацию.

## Anzer lang

### Типы

Система типов языка отражает те данные, которые принимают на вход или отдают отдельные сервисы, их композиция или произведение. Формат описания типов - расширенная json-schema, описание любых передаваемых данных производится через ней. Json-schema, в свою очередь,позволяет описать как скалярные, так и составные типы данных, поэтому никакого другого способа описания типов не предусматривается.

Исключение - описание произведения типов. Произведение 2-х типов в данном случае является кортежем из 2-х элементов и предполагает, что сервису, принимающему это произведение передаётся кортеж данных удовлетворяющих обоим типам из произведения.

Новый тип вводится ключевым словом `data` и названием в верхнем регистре, например:

```
data SOURCE = {
  "type": "string"
}
```

В приведённом примере мы определили, что `SOURCE` - это просто строка символов.

Допустимые символы названия: латинские символы в верхнем регистре и символ подчёркивание `_`.

Более сложный пример:

```
data PERSON = {
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    }
  },
  "required": [
    "firstName"
  ]
}
```

Как можно увидеть из вышеопределённого примера, json-schema позволяет гибко описать данные, передаваемые сервису.

Определение типа как произведение типов:

```
data FOO=SOURCE&PERSON
```

Такой тип будет эквивалентен описанию:

```
data FOO = {
  "title": "Person",
  "type": "object",
  "properties": {
    "PERSON": {
      "title": "Person",
      "type": "object",
      "properties": {
        "firstName": {
          "type": "string"
        }
      },
      "required": [
        "firstName"
      ]
    },
    "SOURCE": {
      "type": "string"
    }
  },
  "required": [
    "PERSON",
    "SOURCE"
  ]
}
```

В примере видно, что сервису, ждущему произведение `SOURCE` и `PERSON` необходимо сообщение содержащее все данные.

#### Полиморфизм

В оригинале json-schema не подразумевает никакого наследования или каких-либо форм полиморфизма. Однако, транслятор позволяет сравнить 2 схемы и ответить на вопрос:
сможет ли сервис, принимающий тип `A` принять тип `B`. Для этого в json-schema добавлен полиморфизм подтипов.

Допустим есть сервис `a`, принимающий на вход тип :

```
data A = {
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    }
  },
  "required": [
    "firstName"
  ]
}
```

И есть сервис `b`, результат работы которого имеет тип:

```
data B = {
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    },
    "secondName": {
      "type": "string"
    }
  },
  "required": [
    "firstName",
    "secondName"
  ]
}
```

Здесь `A` требует наличие в документе поля `firstName`, поэтому подойдёт любой объект, который содержит это поле. Тип `B` так же требудет наличие этого поля, 
поэтому можно считать, что сервис `b` вернёт документ в с этим полем. Следовательно, возможна композиция сервисов `a . b`, где `a` принимает на вход результат работы `b`.
Следовательно тип `B` можно считать подтипом `A`.

Если же сервис `B` не содержал в секции `required` ключ `firstName`, то этот тип не требовал бы налиичие в документе этого поля и тогда тип `B` нельзя было бы считать подтипом `A`.

Похожие правила распространяются и на свойства полей: e.g. длину строки, регулярное выражние, etc.

### Функции

Язык описывает не композицию сервисов, а композицию функций. Функция в свою очередь может быть λ-сервисом, композицией других функций или произведением функций.

#### Функции как сервисы

Функция как сервис имеет только сигнатуру и не имеет тела:

```
init :: _ -> SOURCE {
    "env": {
        "abc": "111"
    }
}
```

Сигнатура функции определяет какой тип данных принимает сервис на вход, какой является результатом его работы. `_` - пустой тип, аналог отсутствия параметров в императивных языках.

После указания типа результата следует json документ для определения:

1. Имени ENV-переменной, содержащей адрес аргумента сервиса: `env_input`
2. Имени ENV-переменной, содержащей адрес результата сервиса: `env_output`
3. Словаря прочих ENV-переменных, которые необходимо передать сервису: `env`

Этот документ можно сократить до `{}`: по-умолчанию адрес входа будет размещён в переменной `IN`, выхода - в `OUT`.

#### Функции как композиция других функций

Ключевое свойство языка и транслятора - способность описания композиции сервисов. Композиция `a . b` подразумевает, что результат работы `b` будет передан сервису `a` на вход.

Для более удобного описания сложных систем, повторяющиеся композиции можно описать функциями. Сигнатура таких функций будет такая же, но вместо json-описания будет присутствовать определение функции:

```
composition1 :: _ -> RESULT
composition1 = action . init
```

В сигнатуре `composition1` указано, что эта функция будет не будет ждать входа, а результатом её работы будет объекти типа `RESULT`. Если посмотреть на определение, то
видно, что `composition1` является синоним функции `action`, которая получает результат работы от `init`. `init` в самом деле имеет пустой параметр, а результатом
работы `action` является `RESULT` (описания этой функции пропущено). 

Функцию `composition1` можно использовать для композиции с другими или считать, что это и есть основная функция системы.

#### Функции как произведения функций

Так как может существовать тип `C = A&B`, то может существовать и сервис, принимающий тип `C`, и 2 сервиса отдающие `A` и `B` соответственно. Для описания, что функции 
необзодим результат работы 2-х других, сущесвует конструкция `<a,b>`. Она определяет, что когда `a` и `b` закончат работу, их данные необходимо объеденить и передать дальше.

Произведение можно использовать как отдельную функцию или как композицию других:

```
prod1 :: _ -> C
prod1 = <a,b>

composition1 :: _ -> C
composition1 = prod1 . init
```

### Anzer lang и теория категорий

Язык вдохновлён Haskell и так же представляет собой простейшую категорию (см. [теория категорий](https://ru.wikipedia.org/wiki/Теория_категорий)). 

С категорной точки зрения, тип в anzer lang - это объект. Функции являюстя морфизмами (стрелками). Функции-стрелки отображают одни типы на другие. Композиция
функций - это композиция стрелок. Произведение типов - это произведение объектов. Пустой тип '_' - начальный объект.

В теории категорий не может быть стрелки, соединяющий более 2-х объектов. Так же и в anzer lang не может быть сервиса, получающего вход от двух других сервисов.
Вместо этого используется поняти произведения объектов и вводится пониятие произведения функций. Вольный пересказ определения произведения в теории категорий: 
есть тип `A` и стрелки `b: A -> B`, `c: A -> C`, то может быть определена стрелка `f: A -> B*C`. 

Стрелки `b` и `c` - это сервисы из произведения. Их результат - данные типов `B` и `C` соответственно. Для работы сервиса, которому необходимо произведение `B*C`
автоматически добавляется промежуточный сервис, осущесвляющий обхединение данные в тип-произведение. Этот сервис можно считать стрелкой `f`.
