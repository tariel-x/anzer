package golang

import (
	"text/template"
)

var dockerfile = `
FROM tarielx/anzer:latest
WORKDIR /exec
COPY main.go main.go
RUN go mod init github.com/anzer/exec
RUN go build
RUN zip action.zip exec
`

var dockerfileDebug = `
FROM tarielx/anzer:latest
WORKDIR /exec
COPY main.go main.go
RUN go mod init github.com/anzer/exec
RUN go build
RUN go mod vendor
RUN zip -r action.zip *
`

var makefile = `
all: init build zip

init:
	go mod init github.com/anzer/exec

build:
	go build

zip:
	zip action.zip exec
`

var funcTemplate = template.Must(template.New("").Parse(`// Thank robots for this file that was generated for you at {{ .Timestamp }}
package {{ .Package }}

{{ .TypeIn}}

{{ .TypeOut}}

func Handle(input TypeIn) TypeOut {
	var out TypeOut
	return out
}
`))

var execTemplate = template.Must(template.New("").Parse(`
// This file was generated by robots for you at {{ .Timestamp }}
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"{{ .PackagePath }}"
)

type whiskInput struct {
	Value json.RawMessage ` + "`" + `json:"value"` + "`" + `
}

type whiskOutput json.RawMessage

type rawInput map[string]interface{}

func main() {
	// debucging
	var debug = os.Getenv("OW_DEBUG") != ""

	if debug {
		filename := os.Getenv("OW_DEBUG")
		f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
		if err == nil {
			log.SetOutput(f)
			defer f.Close()
		}
		log.Printf("ACTION ENV: %v", os.Environ())
	}

	// input
	out := os.NewFile(3, "pipe")
	defer out.Close()
	reader := bufio.NewReader(os.Stdin)

	// read-eval-print loop
	if debug {
		log.Println("started")
	}
	for {
		// read one line
		inbuf, err := reader.ReadBytes('\n')
		if err != nil {
			if err != io.EOF {
				log.Println(err)
			}
			break
		}
		if debug {
			log.Printf(">>>'%s'>>>", inbuf)
		}

		// parse one line
		raw := rawInput{}
		if err := json.Unmarshal(inbuf, &raw); err != nil {
			printError(out, err)
			continue
		}
		input := whiskInput{}
		if err := json.Unmarshal(inbuf, &input); err != nil {
			printError(out, err)
			continue
		}
		
		log.Printf("RAW %v\n", raw)

		setEnvironment(raw)

		// process the request
		output, err := callHandler(input)
		if err != nil {
			printError(out, err)
			continue
		}

		output = bytes.Replace(output, []byte("\n"), []byte(""), -1)
		if debug {
			log.Printf("'<<<%s'<<<", output)
		}
		fmt.Fprintf(out, "%s\n", output)
	}
}

func printError(out io.Writer, err error) {
	log.Println(err.Error())
	fmt.Fprintf(out, "{ error: %q}\n", err.Error())
}

func setEnvironment(raw map[string]interface{}) {
	for k, v := range raw {
		if k == "value" {
			continue
		}
		if s, ok := v.(string); ok {
			os.Setenv("__OW_"+strings.ToUpper(k), s)
		}
	}
}

func callHandler(input whiskInput) (whiskOutput, error) {
	var anzHandlerInput AnzerIn
	if err := json.Unmarshal(input.Value, &anzHandlerInput); err != nil {
		return whiskOutput{}, err
	}
	log.Printf("ANZ HANDLER IN %#v\n", anzHandlerInput)
	anzHandlerOutput := {{ .Package }}.Handle({{ .Package }}.TypeIn(anzHandlerInput))
	handlerOutput := AnzerOut(anzHandlerOutput)
	output, err := json.Marshal(handlerOutput)
	log.Printf("ANZ HANDLER OUT %v\n", string(output))
	return output, err
}

{{ .AnzerIn}}

{{ .AnzerOut}}

`))
